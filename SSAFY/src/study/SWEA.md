# SW Expert Academy - Computational Thinking
## 프로그래밍과 논리/수학
나는 어떻게 프로그램을 짜면 더 빠른지, 느린지 감이 없다.
나는 log n이 무슨 뜻인지 한마디로 설명하지 못한다.
그렇다면 나는 논리적으로 정확하게 확인하는 연습이 필요하다. 
되는 것 같다는 기분이나 공식을 외우는 것 말고 정확하게 확인해 본 적이 있는가?
프로그램을 짜기 시작하기 전에, 정확한 결과가 나올 것인지, 얼마나 빠르게 돌아갈 것인지 미리 알 수 있는가?
확인하지 않고 프로그램을 짜기 시작하면, 제대로 된 결과가 나오지 않았을 때 고치는 것이 어렵고 무작정 여러가지를 시도해 볼 수 밨에 없다.(지금 내가 하는 것)

정확하게 확인하는 과정을 수많은 세월 동안 정리해 둔 것이 "증명"기법이다.
증명 기법은 기발한 아이디어들의 집합이고 이해하면 재미있는 그림들과 같다.

### Hard Logic vs Soft Logic
카드 문제와 맥주집 문제는 논리적 구조가 똑같은 문제임
하지만 맥주집 문제를 풀 때는 정답을 맞출 수 있음
직관을 사용하여 문제를 풀면 (익숙한 상황에서) 빠르게 문제를 해결할 수 있지만 정확하지 않다는 단점이 있다. 또한 직관은 강한 착각을 일으킨다.

같은 문장 표현을 사용하더라도 그 안의 의미는 다를 수 있다.
우리는 일상에서 직관을 이용해 이런 문장들의 논리를 구별하고 있다.
일상 생활에서는 Soft Logic이 빠르기 때문에 유용하다.
논리적으로 부정확한 표현을 사용하지만, 어떤 의미인지 모든 사람이 이미 알고 있다는 가정이 존재한다.
하지만 프로그래밍은 Hard Logic을 사용한다.
프로그래밍 언어의 표현들은 모두 논리학에서 나왔다. 즉 사용되는 수많은 알고리즘들을 이해하기 위해서는 Hard Logic이 필요하다.

### 오해의 근원
Soft Logic으로 알고리즘을 이해하려고 하는 것!
알고리즘 설명을 봐도 이해가 안되는 것은 증명을 안 봤기 때문이다. 
증명을 봐도 이해가 안되는 것은 직관으로 이해하려고 하기 때문!
알고리즘이 조금만 어려워지면 직관으로 완전한 이해를 얻는 것은 사실상 불가능하다.

### 논리 연습
다음 약속을 지켰는가?
"만약 백점을 받으면, 치킨을 사줄게"
4가지 케이스가 있다.
1. 백점을 받아서 치킨을 사줌 -> 참
2. 백점을 받았는데 치킨을 안 사줌 -> 거짓
3. 백점을 못 받아서 치킨을 안 사줌 -> 참
4. 백점을 못 받았는데 치킨을 사줌 -> 참!

앞의 가정이 거짓이라면 뒤의 명제의 참/거짓 여부에 상관없이 해당 명제식은 참이 된다.
백점을 못 받았을 때, 치킨을 사주고 안 사주고는 전체 명제식의 참 여부에 영향을 주지 않는다.

명제식: p -> q, p 명제가 거짓이면 q 명제의 참/거짓 여부에 상관없이 해당 명제식은 참이다.

### 역, 이, 대우
p -> q 일 때,
- 역: q -> p
- 이: \~p -> ~q
- 대우: \~q -> ~p

### 증명
증명은 정확한 명제식으로 표현할 수 있는 것이라야 한다. 보통은 정확한 명제식까지 쓰지는 않으나 근본적으로는 명제식으로 바꿀 수 있다.

증명에 대한 수많은 오해가 p -> q를 p <-> q와 혼동하는 것에서 일어난다.

#### 증명 풀이 방법
1. 진리표를 사용하여 명제식을 간단하게 증명할 수 있다.
2. n이 짝수일 경우, n=2k로 정의하고 해당 명제가 2*(어떤수식) 형태임을 증명한다.
3. n이 홀수일 경우, n=2k+1로 정의하고 해당 명제가 2*(어떤수식)+1의 형태임을 증명한다.
4. 자연수 n에 대해 홀수(짝수)임을 증명할 때는, n이 짝수인 경우와 홀수인 경우를 따로 증명한다.
5. 명제가 어려울 경우, 대우를 증명한다.

#### 당구공 Paradox
"모든 당구공은 색이 같다를 수학적 귀납법으로 증명하자"
수학적 귀납법에서 필요한 것은 P(n) -> P(n+1)이 참임을 보이는 것 뿐이므로 P(n)이 정말로 참일 필요는 없다. p -> q 에서 앞의 p가 거짓이면 전체 명제는 참이 된다. 그러므로 수학적 귀납법에서 P(n)이 거짓이면 전체 명제가 참이 되므로, P(n)의 참/거짓 여부는 중요하지 않다.

### 항진명제와 모순명제
명제에 포함된 명제 변수들의 진리값에 관계없이 항상 참인 명제를 항진명제(tautology)라 하고, 항상 거짓인 명제를 모순명제(contradiction)라 한다.


## 수와 표현
컴퓨터는 0과 1로 표현할 수 있는 비트들을 모아 수를 표현한다. 
그래서 k개의 비트를 사용하면 최대 2^k 가지의 값을 표현하는 것이 가능하다.

어떤 값 n을 표현하기 위해서는 몇 개의 비트가 필요한가?
2^k-1 >= n이 성립해야 한다. 즉 2^k >= n+1이다.
같은 의미로, k >= log(n+1)이다. (x=log n과 2^x=n은 같은 말임)
즉 어떤 값 n을 표현하기 위해서는 약 log n 비트가 필요하다.

위의 식을 잘 보면 log n의 의미는 아래와 같다.
1. 2의 몇 승이 n이 되느냐의 답
2. n을 표현하는 데 몇 비트가 필요한가의 답
3. 1로 시작해서 계속 두 배를 할 때 몇 번 하면 n이 되느냐의 답
4. n을 2로 계속 나눌 때 몇 번 나누면 거의 1이 되느냐의 대한 답


## 재귀/동적 프로그래밍

## 조합론/기초 알고리즘 프로그래밍 과제


